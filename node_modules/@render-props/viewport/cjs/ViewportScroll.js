'use strict'

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault')

exports.__esModule = true
exports.default = ViewportScroll
exports.ViewportScroll_ = void 0

var _extends2 = _interopRequireDefault(
  require('@babel/runtime/helpers/extends')
)

var _react = _interopRequireDefault(require('react'))

var _propTypes = _interopRequireDefault(require('prop-types'))

var _events = _interopRequireDefault(require('@render-props/events'))

var _throttle = require('@render-props/throttle')

var _scrollable = require('@render-props/scrollable')

var _statics = require('./statics')

/**
<ViewportScroll withCoords={true}>
  {
    ({scrollX, scrollY, scrollTo}) => (
      <Row>
        <Col x={4}>scrollX: {scrollX}</Col>
        <Col x={4}>scrollY: {scrollY}</Col>
        <Col x={8}>
          scrollTo
          <input
            type='number'
            min={0}
            value={scrollY}
            onChange={e => scrollTo(0, e.target.value)}
          />
        </Col>
      </Row>
    )
  }
</ViewportScroll>
**/
const getScroll = () => {
  return {
    scrollX:
      _statics.win.scrollX !== void 0
        ? _statics.win.scrollX
        : _statics.win.pageXOffset === void 0
        ? 0
        : _statics.win.pageXOffset,
    scrollY:
      _statics.win.scrollY !== void 0
        ? _statics.win.scrollY
        : _statics.win.pageYOffset === void 0
        ? 0
        : _statics.win.pageYOffset,
  }
}

function _ref(x, y, opt) {
  if (typeof opt !== 'object') {
    _statics.win.scrollTo(x, y)
  } else {
    const currentPos = getScroll()
    ;(0, _scrollable.scrollTo)(
      _statics.win,
      {
        x: currentPos.scrollX,
        y: currentPos.scrollY,
      },
      {
        x,
        y,
      },
      opt
    )
  }
}

class ViewportScroll_ extends _react.default.Component {
  constructor(props) {
    super(props)
    this.scrollTo = _ref
    this.setScroll = (0, _throttle.throttle)(() => this.forceUpdate())
    this.viewportScrollContext = {
      scrollTo: this.scrollTo,
    }
    this.prevState = null
  }

  componentDidMount() {
    this.props.addEvent(_statics.win, 'scroll', this.setScroll)
  }

  componentWillUnmount() {
    this.setScroll.cancel()
  }

  render() {
    const scroll = getScroll()
    const prevState = this.prevState

    function _ref2() {
      return (0, _scrollable.getDistance)(prevState, scroll)
    }

    function _ref3() {
      return (0, _scrollable.getDirection)(prevState, scroll)
    }

    if (this.props.withCoords === true) {
      this.viewportScrollContext.scrollX = scroll.scrollX
      this.viewportScrollContext.scrollY = scroll.scrollY
      const distance = (0, _scrollable.getDistance)(
        prevState || this.viewportScrollContext,
        scroll
      )
      const direction = (0, _scrollable.getDirection)(
        prevState || this.viewportScrollContext,
        scroll
      )
      this.viewportScrollContext.distance = distance
      this.viewportScrollContext.direction = direction
      scroll.distance = distance
      scroll.direction = direction
    } else {
      this.viewportScrollContext.getScroll = getScroll
      this.viewportScrollContext.getDistance = _ref2
      this.viewportScrollContext.getDirection = _ref3
    }

    this.prevState = scroll
    return this.props.children(this.viewportScrollContext)
  }
}

exports.ViewportScroll_ = ViewportScroll_
ViewportScroll_.displayName = 'ViewportScroll'
ViewportScroll_.propTypes = {
  children: _propTypes.default.func.isRequired,
  withCoords: _propTypes.default.bool,
}
ViewportScroll_.defaultProps = {
  withCoords: true,
}

function ViewportScroll(props) {
  return _react.default.createElement(_events.default, null, function(
    eventsContext
  ) {
    return _react.default.createElement(
      ViewportScroll_,
      (0, _extends2.default)({}, eventsContext, {
        withCoords: props.withCoords,
        children: props.children,
      })
    )
  })
}
