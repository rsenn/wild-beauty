{"version":3,"file":"index.es.js","sources":["../src/FlipToolkit/utilities/index.ts","../src/FlipToolkit/forked-rebound/onFrame.js","../src/FlipToolkit/springSettings/index.ts","../src/FlipToolkit/forked-rebound/util.js","../src/FlipToolkit/forked-rebound/Loopers.js","../src/FlipToolkit/forked-rebound/Spring.js","../src/FlipToolkit/forked-rebound/SpringSystem.js","../src/FlipToolkit/flip/animateFlippedElements/spring/index.ts","../src/FlipToolkit/flip/animateFlippedElements/index.ts","../src/FlipToolkit/flip/getFlippedElementPositions/utilities.ts","../src/FlipToolkit/Spring/index.ts","../src/Flipper/context.ts","../src/Flipper/index.tsx","../src/FlipToolkit/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts","../src/FlipToolkit/flip/index.ts","../src/FlipToolkit/flip/getFlippedElementPositions/getFlippedElementPositionsAfterUpdate/index.ts","../src/FlipToolkit/flip/animateUnflippedElements/index.ts","../src/Flipped/index.tsx","../src/FlipToolkit/constants.ts","../src/ExitContainer/index.tsx"],"sourcesContent":["import { IndexableObject } from './types'\n\nexport const isNumber = (x: any) => typeof x === 'number'\n\nexport const isFunction = (x: any) => typeof x === 'function'\n\nexport const isObject = (x: any) =>\n  Object.prototype.toString.call(x) === '[object Object]'\n\nexport const toArray = (arrayLike: ArrayLike<any>) =>\n  Array.prototype.slice.apply(arrayLike)\n\nexport const getDuplicateValsAsStrings = (arr: string[]): string[] => {\n  const baseObj: IndexableObject = {}\n  const obj = arr.reduce((acc, curr) => {\n    acc[curr] = (acc[curr] || 0) + 1\n    return acc\n  }, baseObj)\n  return Object.keys(obj).filter(val => obj[val] > 1)\n}\n\n// tslint only likes this with a regular function, not an arrow function\nexport function assign(\n  target: IndexableObject,\n  ...args: IndexableObject[]\n): object {\n  args.forEach(arg => {\n    if (!arg) {\n      return\n    }\n    // Skip over if undefined or null\n    for (const nextKey in arg) {\n      // Avoid bugs when hasOwnProperty is shadowed\n      if (Object.prototype.hasOwnProperty.call(arg, nextKey)) {\n        target[nextKey] = arg[nextKey]\n      }\n    }\n  })\n  return target\n}\n\nexport const tweenProp = (start: number, end: number, position: number) =>\n  start + (end - start) * position\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nlet _onFrame\nif (typeof window !== \"undefined\") {\n  _onFrame = window.requestAnimationFrame\n}\n\n_onFrame =\n  _onFrame ||\n  function(callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\nexport default _onFrame\n","import { isObject, assign } from '../utilities'\nimport { SpringPresets, SpringConfig, SpringOption } from './types'\n\n// adapted from\n// https://github.com/chenglou/react-motion/blob/master/src/presets.js\nexport const springPresets: SpringPresets = {\n  noWobble: { stiffness: 200, damping: 26 },\n  gentle: { stiffness: 120, damping: 14 },\n  veryGentle: { stiffness: 130, damping: 17 },\n  wobbly: { stiffness: 180, damping: 12 },\n  stiff: { stiffness: 260, damping: 26 }\n}\n\nfunction argIsSpringConfig(\n  arg: SpringConfig | keyof SpringPresets | undefined\n): arg is SpringConfig {\n  return isObject(arg)\n}\n\nexport const normalizeSpring = (\n  spring?: SpringConfig | keyof SpringPresets | any\n) => {\n  if (argIsSpringConfig(spring)) {\n    return spring\n  } else if (Object.keys(springPresets).indexOf(spring) > -1) {\n    return springPresets[spring]\n  } else {\n    return {}\n  }\n}\n\nexport const getSpringConfig = ({\n  flipperSpring,\n  flippedSpring\n}: { flipperSpring?: SpringOption; flippedSpring?: SpringOption } = {}) => {\n  return assign(\n    {},\n    springPresets.noWobble,\n    normalizeSpring(flipperSpring),\n    normalizeSpring(flippedSpring)\n  )\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nexport { default as onFrame } from './onFrame'\n\nconst start = Date.now()\nexport const performanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function'\n    ? () => performance.now()\n    : () => Date.now() - start\n\n// Lop off the first occurence of the reference in the Array.\nexport function removeFirst(array, item) {\n  const idx = array.indexOf(item)\n  idx !== -1 && array.splice(idx, 1)\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { onFrame, performanceNow } from \"./util\"\n\n/**\n * Plays each frame of the SpringSystem on animation\n * timing loop. This is the default type of looper for a new spring system\n * as it is the most common when developing UI.\n * @public\n */\nexport class AnimationLooper {\n  run() {\n    onFrame(() => {\n      this.springSystem.loop(performanceNow())\n    })\n  }\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { removeFirst } from './util'\n\nclass PhysicsState {\n  constructor() {\n    this.position = 0\n    this.velocity = 0\n  }\n}\n\nlet ID = 0\nconst MAX_DELTA_TIME_SEC = 0.064\nconst SOLVER_TIMESTEP_SEC = 0.001\n\n/**\n * Provides a model of a classical spring acting to\n * resolve a body to equilibrium. Springs have configurable\n * tension which is a force multipler on the displacement of the\n * spring from its rest point or `endValue` as defined by [Hooke's\n * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have\n * configurable friction, which ensures that they do not oscillate\n * infinitely. When a Spring is displaced by updating it's resting\n * or `currentValue`, the SpringSystems that contain that Spring\n * will automatically start looping to solve for equilibrium. As each\n * timestep passes, `SpringListener` objects attached to the Spring\n * will be notified of the updates providing a way to drive an\n * animation off of the spring's resolution curve.\n * @public\n */\nclass Spring {\n  constructor(springSystem) {\n    this._id = `s${ID++}`\n    this._springSystem = springSystem\n\n    this.listeners = []\n    this._startValue = 0\n\n    this._currentState = new PhysicsState()\n    this._displacementFromRestThreshold = 0.001\n    this._endValue = 0\n    this._overshootClampingEnabled = false\n    this._previousState = new PhysicsState()\n    this._restSpeedThreshold = 0.001\n\n    this._tempState = new PhysicsState()\n    this._timeAccumulator = 0\n    this._wasAtRest = true\n    // hack from alex -- only call 1x\n    this._onActivateCalled\n    this._cachedSpringConfig = {}\n  }\n\n  getId() {\n    return this._id\n  }\n\n  /**\n   * Remove a Spring from simulation and clear its listeners.\n   * @public\n   */\n  destroy() {\n    this.listeners = []\n    this._springSystem.deregisterSpring(this)\n  }\n\n  /**\n   * Set the configuration values for this Spring. A SpringConfig\n   * contains the tension and friction values used to solve for the\n   * equilibrium of the Spring in the physics loop.\n   * @public\n   */\n  setSpringConfig(springConfig) {\n    this._springConfig = springConfig\n    return this\n  }\n  /**\n   * Retrieve the current value of the Spring.\n   * @public\n   */\n  getCurrentValue() {\n    return this._currentState.position\n  }\n\n  /**\n   * Get the absolute distance of the Spring from a given state value\n   */\n  getDisplacementDistanceForState(state) {\n    return Math.abs(this._endValue - state.position)\n  }\n\n  /**\n   * Set the endValue or resting position of the spring. If this\n   * value is different than the current value, the SpringSystem will\n   * be notified and will begin running its solver loop to resolve\n   * the Spring to equilibrium. Any listeners that are registered\n   * for onSpringEndStateChange will also be notified of this update\n   * immediately.\n   * @public\n   */\n\n  setEndValue(endValue) {\n    if (endValue === this._endValue) return this\n    this.prevEndValue = endValue\n    if (this._endValue === endValue && this.isAtRest()) {\n      return this\n    }\n    this._startValue = this.getCurrentValue()\n    this._endValue = endValue\n    this._springSystem.activateSpring(this.getId())\n    for (let i = 0, len = this.listeners.length; i < len; i++) {\n      const listener = this.listeners[i]\n      const onChange = listener.onSpringEndStateChange\n      onChange && onChange(this)\n    }\n    return this\n  }\n\n  /**\n   * Set the current velocity of the Spring, in pixels per second. As\n   * previously mentioned, this can be useful when you are performing\n   * a direct manipulation gesture. When a UI element is released you\n   * may call setVelocity on its animation Spring so that the Spring\n   * continues with the same velocity as the gesture ended with. The\n   * friction, tension, and displacement of the Spring will then\n   * govern its motion to return to rest on a natural feeling curve.\n   * @public\n   */\n  setVelocity(velocity) {\n    if (velocity === this._currentState.velocity) {\n      return this\n    }\n    this._currentState.velocity = velocity\n    this._springSystem.activateSpring(this.getId())\n    return this\n  }\n\n  setCurrentValue(currentValue) {\n    this._startValue = currentValue\n    this._currentState.position = currentValue\n    for (var i = 0, len = this.listeners.length; i < len; i++) {\n      var listener = this.listeners[i]\n      listener.onSpringUpdate && listener.onSpringUpdate(this)\n    }\n    return this\n  }\n\n  setAtRest() {\n    this._endValue = this._currentState.position\n    this._tempState.position = this._currentState.position\n    this._currentState.velocity = 0\n    return this\n  }\n\n  /**\n   * Enable overshoot clamping. This means that the Spring will stop\n   * immediately when it reaches its resting position regardless of\n   * any existing momentum it may have. This can be useful for certain\n   * types of animations that should not oscillate such as a scale\n   * down to 0 or alpha fade.\n   * @public\n   */\n  setOvershootClampingEnabled(enabled) {\n    this._overshootClampingEnabled = enabled\n    return this\n  }\n\n  /**\n   * Check if the Spring has gone past its end point by comparing\n   * the direction it was moving in when it started to the current\n   * position and end value.\n   * @public\n   */\n  isOvershooting() {\n    const start = this._startValue\n    const end = this._endValue\n    return (\n      this._springConfig.tension > 0 &&\n      ((start < end && this.getCurrentValue() > end) ||\n        (start > end && this.getCurrentValue() < end))\n    )\n  }\n\n  /**\n   * The main solver method for the Spring. It takes\n   * the current time and delta since the last time step and performs\n   * an RK4 integration to get the new position and velocity state\n   * for the Spring based on the tension, friction, velocity, and\n   * displacement of the Spring.\n   * @public\n   */\n  advance(time, realDeltaTime) {\n    let isAtRest = this.isAtRest()\n\n    if (isAtRest && this._wasAtRest) {\n      return\n    }\n\n    let adjustedDeltaTime = realDeltaTime\n    if (realDeltaTime > MAX_DELTA_TIME_SEC) {\n      adjustedDeltaTime = MAX_DELTA_TIME_SEC\n    }\n\n    this._timeAccumulator += adjustedDeltaTime\n\n    const tension = this._springConfig.tension\n    const friction = this._springConfig.friction\n    let position = this._currentState.position\n    let velocity = this._currentState.velocity\n    let tempPosition = this._tempState.position\n    let tempVelocity = this._tempState.velocity\n    let aVelocity\n    let aAcceleration\n    let bVelocity\n    let bAcceleration\n    let cVelocity\n    let cAcceleration\n    let dVelocity\n    let dAcceleration\n    let dxdt\n    let dvdt\n\n    while (this._timeAccumulator >= SOLVER_TIMESTEP_SEC) {\n      this._timeAccumulator -= SOLVER_TIMESTEP_SEC\n\n      if (this._timeAccumulator < SOLVER_TIMESTEP_SEC) {\n        this._previousState.position = position\n        this._previousState.velocity = velocity\n      }\n\n      aVelocity = velocity\n      aAcceleration =\n        tension * (this._endValue - tempPosition) - friction * velocity\n\n      tempPosition = position + aVelocity * SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + aAcceleration * SOLVER_TIMESTEP_SEC * 0.5\n      bVelocity = tempVelocity\n      bAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + bVelocity * SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + bAcceleration * SOLVER_TIMESTEP_SEC * 0.5\n      cVelocity = tempVelocity\n      cAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + cVelocity * SOLVER_TIMESTEP_SEC\n      tempVelocity = velocity + cAcceleration * SOLVER_TIMESTEP_SEC\n      dVelocity = tempVelocity\n      dAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      dxdt =\n        (1.0 / 6.0) * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity)\n      dvdt =\n        (1.0 / 6.0) *\n        (aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration)\n\n      position += dxdt * SOLVER_TIMESTEP_SEC\n      velocity += dvdt * SOLVER_TIMESTEP_SEC\n    }\n\n    this._tempState.position = tempPosition\n    this._tempState.velocity = tempVelocity\n\n    this._currentState.position = position\n    this._currentState.velocity = velocity\n\n    if (this._timeAccumulator > 0) {\n      this._interpolate(this._timeAccumulator / SOLVER_TIMESTEP_SEC)\n    }\n\n    if (\n      this.isAtRest() ||\n      (this._overshootClampingEnabled && this.isOvershooting())\n    ) {\n      if (this._springConfig.tension > 0) {\n        this._startValue = this._endValue\n        this._currentState.position = this._endValue\n      } else {\n        this._endValue = this._currentState.position\n        this._startValue = this._endValue\n      }\n      this.setVelocity(0)\n      isAtRest = true\n    }\n\n    let notifyActivate = false\n    if (this._wasAtRest) {\n      this._wasAtRest = false\n      notifyActivate = true\n    }\n\n    let notifyAtRest = false\n    if (isAtRest) {\n      this._wasAtRest = true\n      notifyAtRest = true\n    }\n\n    this.notifyPositionUpdated(notifyActivate, notifyAtRest)\n  }\n\n  notifyPositionUpdated(notifyActivate, notifyAtRest) {\n    this.listeners.filter(Boolean).forEach(listener => {\n      if (\n        notifyActivate &&\n        listener.onSpringActivate &&\n        !this._onActivateCalled\n      ) {\n        listener.onSpringActivate(this)\n        this._onActivateCalled = true\n      }\n\n      if (listener.onSpringUpdate) {\n        listener.onSpringUpdate(this)\n      }\n\n      if (notifyAtRest && listener.onSpringAtRest) {\n        listener.onSpringAtRest(this)\n      }\n    })\n  }\n\n  /**\n   * Check if the SpringSystem should advance. Springs are advanced\n   * a final frame after they reach equilibrium to ensure that the\n   * currentValue is exactly the requested endValue regardless of the\n   * displacement threshold.\n   * @public\n   */\n  systemShouldAdvance() {\n    return !this.isAtRest() || !this.wasAtRest()\n  }\n\n  wasAtRest() {\n    return this._wasAtRest\n  }\n\n  /**\n   * Check if the Spring is atRest meaning that it's currentValue and\n   * endValue are the same and that it has no velocity. The previously\n   * described thresholds for speed and displacement define the bounds\n   * of this equivalence check. If the Spring has 0 tension, then it will\n   * be considered at rest whenever its absolute velocity drops below the\n   * restSpeedThreshold.\n   * @public\n   */\n  isAtRest() {\n    const isAtRest =\n      Math.abs(this._currentState.velocity) < this._restSpeedThreshold &&\n      (this.getDisplacementDistanceForState(this._currentState) <=\n        this._displacementFromRestThreshold ||\n        this._springConfig.tension === 0)\n    return isAtRest\n  }\n\n  _interpolate(alpha) {\n    this._currentState.position =\n      this._currentState.position * alpha +\n      this._previousState.position * (1 - alpha)\n    this._currentState.velocity =\n      this._currentState.velocity * alpha +\n      this._previousState.velocity * (1 - alpha)\n  }\n\n  addListener(newListener) {\n    this.listeners.push(newListener)\n    return this\n  }\n\n  addOneTimeListener(newListener) {\n    const oneTimeFunc = func => (...args) => {\n      func(...args)\n      this.removeListener(newListener)\n    }\n    Object.keys(newListener).forEach(key => {\n      newListener[key] = oneTimeFunc(newListener[key])\n    })\n    this.listeners.push(newListener)\n    return this\n  }\n\n  removeListener(listenerToRemove) {\n    removeFirst(this.listeners, listenerToRemove)\n    return this\n  }\n}\n\nexport default Spring\n","//\n/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nimport { AnimationLooper } from './Loopers'\nimport Spring from './Spring'\nimport { removeFirst } from './util'\n\n/**\n * A set of Springs that all run on the same physics\n * timing loop. To get started with a Rebound animation, first\n * create a new SpringSystem and then add springs to it.\n * @public\n */\nclass SpringSystem {\n  constructor(looper) {\n    this.looper = looper || new AnimationLooper()\n    this.looper.springSystem = this\n\n    this.listeners = []\n    this._activeSprings = []\n    this._idleSpringIndices = []\n    this._isIdle = true\n    this._lastTimeMillis = -1\n    this._springRegistry = {}\n  }\n\n  /**\n   * Add a new spring to this SpringSystem. This Spring will now be solved for\n   * during the physics iteration loop. By default the spring will use the\n   * default Origami spring config with 40 tension and 7 friction, but you can\n   * also provide your own values here.\n   * @public\n   */\n  createSpring(tension, friction) {\n    return this.createSpringWithConfig({ tension, friction })\n  }\n  /**\n   * Add a spring with the provided SpringConfig.\n   * @public\n   */\n  createSpringWithConfig(springConfig) {\n    const spring = new Spring(this)\n    this.registerSpring(spring)\n    spring.setSpringConfig(springConfig)\n    return spring\n  }\n\n  /**\n   * Check if a SpringSystem is idle or active. If all of the Springs in the\n   * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,\n   * then this method will return true.\n   * @public\n   */\n  getIsIdle() {\n    return this._isIdle\n  }\n\n  /**\n   * Manually add a spring to this system. This is called automatically\n   * if a Spring is created with SpringSystem#createSpring.\n   *\n   * This method sets the spring up in the registry so that it can be solved\n   * in the solver loop.\n   * @public\n   */\n  registerSpring(spring) {\n    this._springRegistry[spring.getId()] = spring\n  }\n\n  /**\n   * Deregister a spring with this SpringSystem. The SpringSystem will\n   * no longer consider this Spring during its integration loop once\n   * this is called. This is normally done automatically for you when\n   * you call Spring#destroy.\n   * @public\n   */\n  deregisterSpring(spring) {\n    removeFirst(this._activeSprings, spring)\n    delete this._springRegistry[spring.getId()]\n  }\n\n  advance(time, deltaTime) {\n    while (this._idleSpringIndices.length > 0) {\n      this._idleSpringIndices.pop()\n    }\n    this._activeSprings.filter(Boolean).forEach(spring => {\n      if (spring.systemShouldAdvance()) {\n        spring.advance(time / 1000.0, deltaTime / 1000.0)\n      } else {\n        this._idleSpringIndices.push(this._activeSprings.indexOf(spring))\n      }\n    })\n\n    while (this._idleSpringIndices.length > 0) {\n      const idx = this._idleSpringIndices.pop()\n      idx >= 0 && this._activeSprings.splice(idx, 1)\n    }\n  }\n\n  /**\n   * This is the main solver loop called to move the simulation\n   * forward through time. Before each pass in the solver loop\n   * onBeforeIntegrate is called on an any listeners that have\n   * registered themeselves with the SpringSystem. This gives you\n   * an opportunity to apply any constraints or adjustments to\n   * the springs that should be enforced before each iteration\n   * loop. Next the advance method is called to move each Spring in\n   * the systemShouldAdvance forward to the current time. After the\n   * integration step runs in advance, onAfterIntegrate is called\n   * on any listeners that have registered themselves with the\n   * SpringSystem. This gives you an opportunity to run any post\n   * integration constraints or adjustments on the Springs in the\n   * SpringSystem.\n   * @public\n   */\n  loop(currentTimeMillis) {\n    let listener\n    if (this._lastTimeMillis === -1) {\n      this._lastTimeMillis = currentTimeMillis - 1\n    }\n    const ellapsedMillis = currentTimeMillis - this._lastTimeMillis\n    this._lastTimeMillis = currentTimeMillis\n\n    let i = 0\n    const len = this.listeners.length\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onBeforeIntegrate && listener.onBeforeIntegrate(this)\n    }\n\n    this.advance(currentTimeMillis, ellapsedMillis)\n    if (this._activeSprings.length === 0) {\n      this._isIdle = true\n      this._lastTimeMillis = -1\n    }\n\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onAfterIntegrate && listener.onAfterIntegrate(this)\n    }\n\n    if (!this._isIdle) {\n      this.looper.run()\n    }\n  }\n\n  /**\n   * Used to notify the SpringSystem that a Spring has become displaced.\n   * The system responds by starting its solver loop up if it is currently idle.\n   */\n  activateSpring(springId) {\n    const spring = this._springRegistry[springId]\n    if (this._activeSprings.indexOf(spring) === -1) {\n      this._activeSprings.push(spring)\n    }\n    if (this.getIsIdle()) {\n      this._isIdle = false\n      this.looper.run()\n    }\n  }\n}\n\nexport default SpringSystem\n","import { SpringSystem } from '../../../forked-rebound'\nimport { StaggerConfigValue } from '../../../types'\nimport { FlipData, FlipDataArray } from '../types'\nimport {\n  SpringSystemInterface,\n  AddListenerArgs\n} from '../../../forked-rebound/types'\n\n// this should get created only 1x\nconst springSystem: SpringSystemInterface = new SpringSystem()\n\nexport const createSuspendedSpring = (flipData: FlipData) => {\n  const {\n    springConfig: { stiffness, damping, overshootClamping },\n    getOnUpdateFunc,\n    onAnimationEnd,\n    onSpringActivate\n  } = flipData\n\n  const spring = springSystem.createSpring(stiffness!, damping!)\n  spring.setOvershootClampingEnabled(!!overshootClamping)\n  const onSpringAtRest = () => {\n    // prevent SpringSystem from caching unused springs\n    spring.destroy()\n    onAnimationEnd()\n  }\n\n  const springConfig: AddListenerArgs = {\n    onSpringActivate,\n    onSpringAtRest,\n    onSpringUpdate: getOnUpdateFunc({\n      spring,\n      onAnimationEnd\n    })\n  }\n\n  spring.addListener(springConfig)\n  return spring\n}\n\nexport const createSpring = (flipped: FlipData) => {\n  const spring = createSuspendedSpring(flipped)\n  spring.setEndValue(1)\n  return spring\n}\n\nexport const normalizeSpeed = (speedConfig: number | undefined) => {\n  if (typeof speedConfig !== 'number') return 1.1\n  return 1 + Math.min(Math.max(speedConfig * 5, 0), 5)\n}\n\nexport const createStaggeredSprings = (\n  flippedArray: FlipDataArray,\n  staggerConfig: StaggerConfigValue = {}\n) => {\n  if (!flippedArray || !flippedArray.length) {\n    return\n  }\n\n  if (staggerConfig.reverse) {\n    flippedArray.reverse()\n  }\n\n  const normalizedSpeed = normalizeSpeed(staggerConfig.speed)\n\n  const nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10)\n\n  const setEndValueFuncs = flippedArray\n    .map((flipped, i) => {\n      const cachedGetOnUpdate = flipped.getOnUpdateFunc\n\n      // modify the update function to adjust\n      // the end value of the trailing Flipped component\n      flipped.getOnUpdateFunc = args => {\n        const onUpdate = cachedGetOnUpdate(args)\n        return spring => {\n          let currentValue = spring.getCurrentValue()\n          // make sure trailing animations complete\n          currentValue =\n            currentValue < 0.01 ? 0 : currentValue > 0.99 ? 1 : currentValue\n\n          const updateTrailingAnimation = currentValue >= nextThreshold\n          if (updateTrailingAnimation) {\n            if (setEndValueFuncs[i + 1]) {\n              setEndValueFuncs[i + 1]!(\n                Math.max(Math.min(currentValue * normalizedSpeed, 1), 0)\n              )\n            }\n          }\n          // now call the actual update function\n          onUpdate(spring)\n        }\n      }\n      return flipped\n    })\n    .map(flipped => {\n      const spring = createSuspendedSpring(flipped)\n      if (!spring) {\n        return\n      }\n      return spring.setEndValue.bind(spring)\n    })\n    .filter(Boolean)\n\n  if (setEndValueFuncs[0]) {\n    setEndValueFuncs[0]!(1)\n  }\n}\n","import * as Rematrix from 'rematrix'\nimport { getSpringConfig } from '../../springSettings'\nimport {\n  toArray,\n  isFunction,\n  isNumber,\n  getDuplicateValsAsStrings,\n  assign,\n  tweenProp\n} from '../../utilities'\nimport * as constants from '../../constants'\nimport {\n  GetOnUpdateFunc,\n  OnUpdate,\n  Matrix,\n  InvertedChildren,\n  AnimateFlippedElementsArgs,\n  AnimatedVals,\n  FlipDataArray,\n  FlipData,\n  InitializeFlip\n} from './types'\nimport { BoundingClientRect } from '../getFlippedElementPositions/types'\nimport { FlippedIds } from '../types'\nimport { createSpring, createStaggeredSprings } from './spring'\nimport { IndexableObject } from '../../utilities/types'\nimport { FlipId } from '../../types'\n\n// 3d transforms were causing weird issues in chrome,\n// especially when opacity was also being tweened,\n// so convert to a 2d matrix\nexport const convertMatrix3dArrayTo2dArray = (matrix: Matrix): Matrix =>\n  [0, 1, 4, 5, 12, 13].map(index => matrix[index])\n\nexport const convertMatrix2dArrayToString = (matrix: Matrix) =>\n  `matrix(${matrix.join(', ')})`\n\nexport const invertTransformsForChildren = ({\n  invertedChildren,\n  matrix,\n  body\n}: {\n  matrix: Matrix\n  body: HTMLBodyElement\n  invertedChildren: InvertedChildren\n}) => {\n  invertedChildren.forEach(([child, childFlipConfig]) => {\n    if (!body.contains(child)) {\n      return\n    }\n    const scaleX = matrix[0]\n    const scaleY = matrix[3]\n    const translateX = matrix[4]\n    const translateY = matrix[5]\n\n    const inverseVals = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }\n    let transformString = ''\n    if (childFlipConfig.translate) {\n      inverseVals.translateX = -translateX / scaleX\n      inverseVals.translateY = -translateY / scaleY\n      transformString += `translate(${inverseVals.translateX}px, ${inverseVals.translateY}px)`\n    }\n    if (childFlipConfig.scale) {\n      inverseVals.scaleX = 1 / scaleX\n      inverseVals.scaleY = 1 / scaleY\n      transformString += ` scale(${inverseVals.scaleX}, ${inverseVals.scaleY})`\n    }\n    child.style.transform = transformString\n  })\n}\n\nexport const createApplyStylesFunc = ({\n  element,\n  invertedChildren,\n  body\n}: {\n  element: HTMLElement\n  invertedChildren: InvertedChildren\n  body: HTMLBodyElement\n}) => ({\n  matrix,\n  opacity,\n  forceMinVals\n}: {\n  matrix: Matrix\n  opacity?: number\n  forceMinVals?: boolean\n}) => {\n  if (isNumber(opacity)) {\n    element.style.opacity = opacity + ''\n  }\n\n  if (forceMinVals) {\n    element.style.minHeight = '1px'\n    element.style.minWidth = '1px'\n  }\n\n  if (!matrix) {\n    return\n  }\n\n  const stringTransform = convertMatrix2dArrayToString(matrix)\n\n  // always apply transform, even if identity,\n  // because identity might be the starting state in a FLIP\n  // transition, if the element's position is controlled by transforms\n  element.style.transform = stringTransform\n\n  if (invertedChildren) {\n    invertTransformsForChildren({\n      invertedChildren,\n      matrix,\n      body\n    })\n  }\n}\n\nexport const rectInViewport = ({\n  top,\n  bottom,\n  left,\n  right\n}: BoundingClientRect) => {\n  return (\n    top < window.innerHeight &&\n    bottom > 0 &&\n    left < window.innerWidth &&\n    right > 0\n  )\n}\n\nconst getInvertedChildren = (element: HTMLElement, id: string) =>\n  toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}=\"${id}\"]`)\n  )\n\nexport default ({\n  flippedIds,\n  flipCallbacks,\n  inProgressAnimations,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  applyTransformOrigin,\n  spring,\n  getElement,\n  debug,\n  staggerConfig = {},\n  decisionData = {},\n  onComplete,\n  containerEl\n}: AnimateFlippedElementsArgs) => {\n  // the stuff below is used so we can return a promise that resolves when all FLIP animations have\n  // completed\n  let closureResolve: (flipIds: FlippedIds) => void\n\n  const flipCompletedPromise: Promise<FlippedIds> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n  // hook for users of lib to attach logic when all flip animations have completed\n  if (onComplete) {\n    flipCompletedPromise.then(() => onComplete(containerEl, decisionData))\n  }\n  if (!flippedIds.length) {\n    return () => {\n      closureResolve!([])\n      return flipCompletedPromise\n    }\n  }\n\n  const completedAnimationIds: FlippedIds = []\n\n  const firstElement: HTMLElement = getElement(flippedIds[0])\n  // special handling for iframes\n  const body = firstElement\n    ? firstElement.ownerDocument!.querySelector('body')!\n    : document.querySelector('body')!\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (debug) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '[react-flip-toolkit]\\nThe \"debug\" prop is set to true. All FLIP animations will return at the beginning of the transition.'\n      )\n    }\n  }\n\n  const duplicateFlipIds = getDuplicateValsAsStrings(flippedIds)\n  if (process.env.NODE_ENV !== 'production') {\n    if (duplicateFlipIds.length) {\n      // eslint-disable-next-line no-console\n      console.error(\n        `[react-flip-toolkit]\\nThere are currently multiple elements with the same flipId on the page.\\nThe animation will only work if each Flipped component has a unique flipId.\\nDuplicate flipId${\n          duplicateFlipIds.length > 1 ? 's' : ''\n        }: ${duplicateFlipIds.join('\\n')}`\n      )\n    }\n  }\n\n  const flipDataArray: FlipDataArray = flippedIds\n\n    // take all the measurements we need\n    // and return an object with animation functions + necessary data\n    .map(id => {\n      const prevRect = flippedElementPositionsBeforeUpdate[id].rect\n      const currentRect = flippedElementPositionsAfterUpdate[id].rect\n      const prevOpacity = flippedElementPositionsBeforeUpdate[id].opacity\n      const currentOpacity = flippedElementPositionsAfterUpdate[id].opacity\n      const needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1\n      const element = flippedElementPositionsAfterUpdate[id].element\n\n      // don't animate elements outside of the user's viewport\n      if (!rectInViewport(prevRect) && !rectInViewport(currentRect)) {\n        return false\n      }\n\n      // this might happen if we are rapidly adding & removing elements(?)\n      if (!element) {\n        return false\n      }\n\n      const flipConfig = JSON.parse(element.dataset.flipConfig!)\n\n      const springConfig = getSpringConfig({\n        flipperSpring: spring,\n        flippedSpring: flipConfig.spring\n      })\n\n      const stagger =\n        flipConfig.stagger === true ? 'default' : flipConfig.stagger\n\n      const toReturn = {\n        element,\n        id,\n        stagger,\n        springConfig\n      }\n\n      if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {\n        const elementShouldFlip = flipCallbacks[id].shouldFlip!(\n          decisionData.previous,\n          decisionData.current\n        )\n        if (!elementShouldFlip) {\n          return false\n        }\n      }\n\n      // don't animate elements that didn't visibly change\n      // but possibly animate their children\n\n      const translateXDifference = Math.abs(prevRect.left - currentRect.left)\n      const translateYDifference = Math.abs(prevRect.top - currentRect.top)\n\n      const translateDifference = translateXDifference + translateYDifference\n\n      const scaleXDifference = Math.abs(prevRect.width - currentRect.width)\n      const scaleYDifference = Math.abs(prevRect.height - currentRect.height)\n\n      const scaleDifference = scaleXDifference + scaleYDifference\n\n      const opacityDifference = Math.abs(currentOpacity - prevOpacity)\n      if (\n        translateDifference < 0.5 &&\n        scaleDifference < 0.5 &&\n        opacityDifference < 0.01\n      ) {\n        return false\n      }\n\n      const currentTransform = Rematrix.parse(\n        flippedElementPositionsAfterUpdate[id].transform\n      )\n\n      const toVals: AnimatedVals = { matrix: currentTransform }\n\n      const fromVals: AnimatedVals = { matrix: [] }\n      const transformsArray = [currentTransform]\n\n      // we're only going to animate the values that the child wants animated\n      if (flipConfig.translate) {\n        transformsArray.push(\n          Rematrix.translateX(prevRect.left - currentRect.left)\n        )\n        transformsArray.push(\n          Rematrix.translateY(prevRect.top - currentRect.top)\n        )\n      }\n      // going any smaller than 1px breaks transitions in Chrome\n      if (flipConfig.scale) {\n        transformsArray.push(\n          Rematrix.scaleX(\n            Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)\n          )\n        )\n        transformsArray.push(\n          Rematrix.scaleY(\n            Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)\n          )\n        )\n      }\n\n      if (flipConfig.opacity) {\n        fromVals.opacity = prevOpacity\n        toVals.opacity = currentOpacity\n      }\n\n      let invertedChildren: InvertedChildren = []\n\n      if (\n        !flipCallbacks[id] ||\n        !flipCallbacks[id].shouldInvert ||\n        flipCallbacks[id].shouldInvert!(\n          decisionData.previous,\n          decisionData.current\n        )\n      ) {\n        const invertedChildElements = getInvertedChildren(element, id)\n        invertedChildren = invertedChildElements.map(c => [\n          c,\n          JSON.parse(c.dataset.flipConfig!)\n        ]) as InvertedChildren\n      }\n\n      fromVals.matrix = convertMatrix3dArrayTo2dArray(\n        transformsArray.reduce(Rematrix.multiply)\n      )\n\n      toVals.matrix = convertMatrix3dArrayTo2dArray(toVals.matrix)\n\n      const applyStyles = createApplyStylesFunc({\n        element,\n        invertedChildren,\n        body\n      })\n\n      let onComplete: () => void\n      if (flipCallbacks[id] && flipCallbacks[id].onComplete) {\n        // must cache or else this could cause an error\n        const cachedOnComplete = flipCallbacks[id].onComplete\n        onComplete = () => cachedOnComplete!(element, decisionData)\n      }\n\n      // this should be called when animation ends naturally\n      // but also when it is interrupted\n      // when it is called, the animation has already been cancelled\n      const onAnimationEnd = (isCancellation: boolean) => {\n        delete inProgressAnimations[id]\n        if (isFunction(onComplete)) {\n          onComplete()\n        }\n        // remove identity transform -- this should have no effect on layout\n        element.style.transform = ''\n        invertedChildren.forEach(([element]) => {\n          element.style.transform = ''\n        })\n        if (needsForcedMinVals && element) {\n          element.style.minHeight = ''\n          element.style.minWidth = ''\n        }\n        if (isCancellation) return\n        \n        completedAnimationIds.push(id)\n\n        if (completedAnimationIds.length >= flipDataArray.length) {\n          // we can theoretically call multiple times since a promise only resolves 1x\n          // but that shouldnt happen\n          closureResolve(completedAnimationIds)\n        }\n      }\n\n      const animateOpacity =\n        isNumber(fromVals.opacity) &&\n        isNumber(toVals.opacity) &&\n        fromVals.opacity !== toVals.opacity\n\n      let onStartCalled = false\n\n      const getOnUpdateFunc: GetOnUpdateFunc = ({ spring, onAnimationEnd }) => {\n        inProgressAnimations[id] = {\n          destroy: spring.destroy.bind(spring),\n          onAnimationEnd\n        }\n        const onUpdate: OnUpdate = spring => {\n          if (flipCallbacks[id] && flipCallbacks[id].onSpringUpdate) {\n            flipCallbacks[id].onSpringUpdate!(spring.getCurrentValue())\n          }\n          // trigger the user provided onStart function\n          if (!onStartCalled) {\n            onStartCalled = true\n            if (flipCallbacks[id] && flipCallbacks[id].onStart) {\n              flipCallbacks[id].onStart!(element, decisionData)\n            }\n          }\n\n          const currentValue = spring.getCurrentValue()\n          if (!body.contains(element)) {\n            spring.destroy()\n            return\n          }\n\n          const vals: AnimatedVals = { matrix: [] }\n\n          vals.matrix = fromVals.matrix.map((fromVal, index) =>\n            tweenProp(fromVal, toVals.matrix[index], currentValue)\n          )\n\n          if (animateOpacity) {\n            vals.opacity = tweenProp(\n              fromVals.opacity!,\n              toVals.opacity!,\n              currentValue\n            )\n          }\n          applyStyles(vals)\n        }\n        return onUpdate\n      }\n\n      const initializeFlip: InitializeFlip = () => {\n        // before animating, immediately apply FLIP styles to prevent flicker\n        applyStyles({\n          matrix: fromVals.matrix,\n          opacity: animateOpacity ? fromVals.opacity : undefined,\n          forceMinVals: needsForcedMinVals\n        })\n\n        if (flipCallbacks[id] && flipCallbacks[id].onStartImmediate) {\n          flipCallbacks[id].onStartImmediate!(element, decisionData)\n        }\n        // and batch any other style updates if necessary\n        if (flipConfig.transformOrigin) {\n          element.style.transformOrigin = flipConfig.transformOrigin\n        } else if (applyTransformOrigin) {\n          element.style.transformOrigin = '0 0'\n        }\n\n        invertedChildren.forEach(([child, childFlipConfig]) => {\n          if (childFlipConfig.transformOrigin) {\n            child.style.transformOrigin = childFlipConfig.transformOrigin\n          } else if (applyTransformOrigin) {\n            child.style.transformOrigin = '0 0'\n          }\n        })\n      }\n\n      return assign({}, toReturn, {\n        stagger,\n        springConfig,\n        getOnUpdateFunc,\n        initializeFlip,\n        onAnimationEnd,\n        delayUntil: flipConfig.delayUntil\n      }) as FlipData\n    })\n    // filter out data for all non-animated elements first\n    .filter(Boolean) as FlipDataArray\n\n  flipDataArray.forEach(({ initializeFlip }) => initializeFlip())\n\n  if (debug) {\n    return () => {}\n  }\n\n  const elementIsFlipped = (flipId: FlipId) =>\n    flipDataArray.filter(f => f.id === flipId).length\n\n  const delayedFlip = flipDataArray.filter(\n    f => f.delayUntil && elementIsFlipped(f.delayUntil)\n  )\n\n  // key: flipId value: flip to delay until key is called\n  const delayUntilSprings = {} as IndexableObject\n  // key: flipId value: stagger to delay until key is called\n  const delayUntilStaggers = {} as IndexableObject\n  // key: stagger value: true\n  const delayedStaggerKeys = {} as IndexableObject\n\n  delayedFlip.forEach(flip => {\n    if (flip.stagger) {\n      delayedStaggerKeys[flip.stagger] = true\n      if (delayUntilStaggers[flip.delayUntil!])\n        delayUntilStaggers[flip.delayUntil!].push(flip.stagger)\n      else delayUntilStaggers[flip.delayUntil!] = [flip.stagger]\n    } else {\n      if (delayUntilSprings[flip.delayUntil!])\n        delayUntilSprings[flip.delayUntil!].push(flip)\n      else delayUntilSprings[flip.delayUntil!] = [flip]\n    }\n  })\n\n  const staggerDict = flipDataArray\n    .filter(flipData => flipData.stagger)\n    .reduce(\n      (acc, curr) => {\n        if (acc[curr.stagger]) {\n          acc[curr.stagger].push(curr)\n        } else {\n          acc[curr.stagger] = [curr]\n        }\n        return acc\n      },\n      {} as IndexableObject\n    )\n\n  const immediateFlip = flipDataArray.filter(f => delayedFlip.indexOf(f) === -1)\n\n  immediateFlip.forEach(flipData => {\n    flipData.onSpringActivate = () => {\n      if (delayUntilSprings[flipData.id]) {\n        delayUntilSprings[flipData.id].forEach(createSpring)\n      }\n      if (delayUntilStaggers[flipData.id]) {\n        const uniqueStaggerKeys = Object.keys(\n          delayUntilStaggers[flipData.id].reduce(\n            (acc: IndexableObject, curr: string) =>\n              assign(acc, { [curr]: true }),\n            {}\n          )\n        )\n        uniqueStaggerKeys.forEach((staggerKey: string) => {\n          createStaggeredSprings(\n            staggerDict[staggerKey],\n            staggerConfig[staggerKey]\n          )\n        })\n      }\n    }\n  })\n\n  return () => {\n    // if there are no active FLIP animations, immediately resolve the\n    // returned promise\n    if (!flipDataArray.length) {\n      closureResolve([])\n    }\n    // animate non-staggered elements\n    immediateFlip\n      .filter(flipData => {\n        return !flipData.stagger\n      })\n      .forEach(createSpring)\n\n    // animate staggered elements\n    Object.keys(staggerDict).forEach(staggerKey => {\n      if (delayedStaggerKeys[staggerKey]) return\n      createStaggeredSprings(staggerDict[staggerKey], staggerConfig[staggerKey])\n    })\n    return flipCompletedPromise\n  }\n}\n","import { toArray, assign } from '../../utilities'\nimport * as constants from '../../constants'\nimport { BoundingClientRect } from './types'\n\nexport const addTupleToObject = (acc: {}, curr: [any, any]) =>\n  assign(acc, { [curr[0]]: curr[1] })\n\nexport const getAllElements = (\n  element?: HTMLElement,\n  portalKey?: string\n): HTMLElement[] => {\n  if (portalKey) {\n    return toArray(\n      document.querySelectorAll(`[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]`)\n    )\n  } else {\n    return toArray(element!.querySelectorAll(`[${constants.DATA_FLIP_ID}]`))\n  }\n}\nexport const getRects = (flippedElements: HTMLElement[]) => {\n  return flippedElements.map((child: HTMLElement): [\n    HTMLElement,\n    BoundingClientRect\n  ] => [child, child.getBoundingClientRect()])\n}\n","// this is exclusively for users of the library to create their own enter + exit animations\nimport { SpringSystem } from '../forked-rebound'\nimport { SpringSystemInterface } from '../forked-rebound/types.d'\nimport { tweenProp, assign } from '../utilities'\nimport { normalizeSpring, springPresets } from '../springSettings'\nimport { SimpleSpringOptions } from './types'\nimport { SpringConfig } from '../springSettings/types'\n\n// this should get created only 1x\nconst springSystem: SpringSystemInterface = new SpringSystem()\n\n/**\n * A simple spring function for animating DOM properties.\n * Returns a function that will immediately cancel the in-progress animation.\n * */\nconst createSimpleSpring = ({\n  config,\n  values,\n  onUpdate,\n  delay = 0,\n  onComplete\n}: SimpleSpringOptions) => {\n  const { stiffness, damping, overshootClamping } = assign(\n    {},\n    springPresets.noWobble,\n    normalizeSpring(config)\n  ) as SpringConfig\n  const spring = springSystem.createSpring(stiffness!, damping!)\n  spring.setOvershootClampingEnabled(!!overshootClamping)\n  spring.addListener({\n    onSpringAtRest: spring => {\n      if (onComplete) onComplete()\n      spring.destroy()\n    },\n    onSpringUpdate: spring => {\n      const springVal = spring.getCurrentValue()\n      if (!values) return onUpdate(springVal)\n      const currentValues = Object.keys(values)\n        .map(value => [\n          value,\n          tweenProp(values[value][0], values[value][1], springVal)\n        ])\n        .reduce((acc, curr) => {\n          return Object.assign(acc, { [curr[0]]: curr[1] })\n        }, {})\n      onUpdate(currentValues)\n    }\n  })\n  if (delay) {\n    setTimeout(() => {\n      spring.setEndValue(1)\n    }, delay)\n  } else {\n    spring.setEndValue(1)\n  }\n  return spring\n}\n\nexport default createSimpleSpring\n","import { createContext } from 'react'\nimport { FlipCallbacks } from '../FlipToolkit/types'\n\nexport const FlipContext = createContext({} as FlipCallbacks)\nexport const PortalContext = createContext('portal')\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  getFlippedElementPositionsBeforeUpdate,\n  onFlipKeyUpdate\n} from '../FlipToolkit'\nimport {\n  FlipperProps,\n  InProgressAnimations,\n  FlipCallbacks\n} from '../FlipToolkit/types'\nimport { FlippedElementPositionsBeforeUpdateReturnVals } from '../FlipToolkit/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/types'\nimport { FlipContext, PortalContext } from './context'\n\nclass Flipper extends Component<FlipperProps> {\n  static defaultProps = {\n    applyTransformOrigin: true,\n    element: 'div'\n  }\n\n  private inProgressAnimations: InProgressAnimations = {}\n  private flipCallbacks: FlipCallbacks = {}\n  private el?: HTMLElement = undefined\n\n  getSnapshotBeforeUpdate(prevProps: FlipperProps) {\n    if (prevProps.flipKey !== this.props.flipKey && this.el) {\n      return getFlippedElementPositionsBeforeUpdate({\n        element: this.el,\n        // if onExit callbacks exist here, we'll cache the DOM node\n        flipCallbacks: this.flipCallbacks,\n        inProgressAnimations: this.inProgressAnimations,\n        portalKey: this.props.portalKey\n      })\n    }\n    return null\n  }\n\n  componentDidUpdate(\n    prevProps: FlipperProps,\n    _prevState: any,\n    cachedData: FlippedElementPositionsBeforeUpdateReturnVals\n  ) {\n    if (this.props.flipKey !== prevProps.flipKey && this.el) {\n      onFlipKeyUpdate({\n        flippedElementPositionsBeforeUpdate: cachedData.flippedElementPositions,\n        cachedOrderedFlipIds: cachedData.cachedOrderedFlipIds,\n        containerEl: this.el,\n        inProgressAnimations: this.inProgressAnimations,\n        flipCallbacks: this.flipCallbacks,\n        applyTransformOrigin: this.props.applyTransformOrigin,\n        spring: this.props.spring,\n        debug: this.props.debug,\n        portalKey: this.props.portalKey,\n        staggerConfig: this.props.staggerConfig,\n        handleEnterUpdateDelete: this.props.handleEnterUpdateDelete,\n        decisionData: {\n          previous: prevProps.decisionData,\n          current: this.props.decisionData\n        },\n        onComplete: this.props.onComplete,\n        onStart: this.props.onStart\n      })\n    }\n  }\n\n  public render() {\n    const { element, className, portalKey } = this.props\n    const Element = element\n\n    let flipperMarkup = (\n      <FlipContext.Provider value={this.flipCallbacks}>\n        {/*\n        // @ts-ignore */}\n        <Element\n          className={className}\n          ref={(el: HTMLElement) => (this.el = el)}\n        >\n          {this.props.children}\n        </Element>\n      </FlipContext.Provider>\n    )\n\n    if (portalKey) {\n      flipperMarkup = (\n        <PortalContext.Provider value={portalKey}>\n          {flipperMarkup}\n        </PortalContext.Provider>\n      )\n    }\n\n    return flipperMarkup\n  }\n}\n// @ts-ignore\n\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-ignore\n  Flipper.propTypes = {\n    flipKey: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.number,\n      PropTypes.bool\n    ]).isRequired,\n    children: PropTypes.node.isRequired,\n    spring: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    applyTransformOrigin: PropTypes.bool,\n    debug: PropTypes.bool,\n    element: PropTypes.string,\n    className: PropTypes.string,\n    portalKey: PropTypes.string,\n    staggerConfig: PropTypes.object,\n    decisionData: PropTypes.any,\n    handleEnterUpdateDelete: PropTypes.func,\n    onComplete: PropTypes.func,\n    onStart: PropTypes.func\n  }\n}\n\nexport default Flipper\n","import { addTupleToObject, getAllElements, getRects } from '../utilities'\nimport * as constants from '../../../constants'\nimport { toArray, assign } from '../../../utilities'\nimport {\n  FlippedElementPositionsBeforeUpdateReturnVals,\n  FlippedElementPositionsBeforeUpdate,\n  GetFlippedElementPositionsBeforeUpdateArgs,\n  ParentBCRs,\n  ChildIdsToParentBCRs,\n  ChildIdsToParents\n} from './types'\nimport { InProgressAnimations } from '../../../types'\n\nexport const cancelInProgressAnimations = (\n  inProgressAnimations: InProgressAnimations,\n  animatingElements: HTMLElement[]\n) => {\n  Object.keys(inProgressAnimations).forEach(id => {\n    if (inProgressAnimations[id].destroy) {\n      inProgressAnimations[id].destroy()\n    }\n    if (inProgressAnimations[id].onAnimationEnd) {\n      inProgressAnimations[id].onAnimationEnd(true)\n    }\n    delete inProgressAnimations[id]\n  })\n  animatingElements.forEach(el => {\n    el.style.transform = ''\n    el.style.opacity = ''\n  })\n}\n\nconst getFlippedElementPositionsBeforeUpdate = ({\n  element,\n  flipCallbacks = {},\n  inProgressAnimations = {},\n  portalKey\n}: GetFlippedElementPositionsBeforeUpdateArgs): FlippedElementPositionsBeforeUpdateReturnVals => {\n  const flippedElements = getAllElements(element, portalKey)\n\n  const inverseFlippedElements = toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}]`)\n  )\n\n  const childIdsToParentBCRs: ChildIdsToParentBCRs = {}\n  const parentBCRs: ParentBCRs = []\n  const childIdsToParents: ChildIdsToParents = {}\n  // this is for exit animations so we can re-insert exiting elements in the\n  // DOM later\n  flippedElements\n    .filter(\n      el =>\n        flipCallbacks &&\n        flipCallbacks[el.dataset.flipId!] &&\n        flipCallbacks[el.dataset.flipId!].onExit\n    )\n    .forEach(el => {\n      let parent = el.parentNode as HTMLElement\n      // this won't work for IE11\n      if (el.closest) {\n        const exitContainer = el.closest(\n          `[${constants.DATA_EXIT_CONTAINER}]`\n        ) as HTMLElement\n        if (exitContainer) {\n          parent = exitContainer\n        }\n      }\n      let bcrIndex = parentBCRs.findIndex(n => n[0] === parent)\n      if (bcrIndex === -1) {\n        parentBCRs.push([parent, parent.getBoundingClientRect()])\n        bcrIndex = parentBCRs.length - 1\n      }\n      childIdsToParentBCRs[el.dataset.flipId!] = parentBCRs[bcrIndex][1]\n      childIdsToParents[el.dataset.flipId!] = parent\n    })\n\n  const filteredFlippedElements = getRects(flippedElements)\n\n  const flippedElementPositions: FlippedElementPositionsBeforeUpdate = filteredFlippedElements\n    .map(([child, childBCR]) => {\n      const domDataForExitAnimations = {}\n\n      // only cache extra data for exit animations\n      // if the element has an onExit listener\n      if (\n        flipCallbacks &&\n        flipCallbacks[child.dataset.flipId!] &&\n        flipCallbacks[child.dataset.flipId!].onExit\n      ) {\n        const parentBCR = childIdsToParentBCRs[child.dataset.flipId!]\n\n        assign(domDataForExitAnimations, {\n          element: child,\n          parent: childIdsToParents[child.dataset.flipId!],\n          childPosition: {\n            top: childBCR.top - parentBCR.top,\n            left: childBCR.left - parentBCR.left,\n            width: childBCR.width,\n            height: childBCR.height\n          }\n        })\n      }\n\n      return [\n        child.dataset.flipId,\n        {\n          rect: childBCR,\n          opacity: parseFloat(window.getComputedStyle(child).opacity || '1'),\n          domDataForExitAnimations\n        }\n      ]\n    })\n    // @ts-ignore\n    .reduce(addTupleToObject, {})\n  // do this at the very end since we want to cache positions of elements\n  // while they are mid-transition\n  cancelInProgressAnimations(\n    inProgressAnimations,\n    flippedElements.concat(inverseFlippedElements)\n  )\n\n  return {\n    flippedElementPositions,\n    cachedOrderedFlipIds: filteredFlippedElements.map(\n      ([el]) => el.dataset.flipId!\n    )\n  }\n}\n\nexport default getFlippedElementPositionsBeforeUpdate\n","import animateUnflippedElements from './animateUnflippedElements'\nimport animateFlippedElements from './animateFlippedElements'\nimport getFlippedElementPositionsAfterUpdate from './getFlippedElementPositions/getFlippedElementPositionsAfterUpdate'\nimport * as constants from '../constants'\nimport { assign, toArray } from '../utilities'\nimport {\n  GetElement,\n  BaseFlipArgs,\n  OnFlipKeyUpdateArgs,\n  FlippedIds\n} from './types'\nimport { AnimateUnflippedElementsArgs } from './animateUnflippedElements/types'\nimport {\n  AnimateFlippedElementsArgs,\n  ScopedSelector\n} from './animateFlippedElements/types'\n\nconst createPortalScopedSelector = (portalKey: string) => (\n  selector: string\n) => {\n  return toArray(\n    document.querySelectorAll(\n      `[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]${selector}`\n    )\n  )\n}\nconst createFlipperScopedSelector = (containerEl: HTMLElement) => {\n  const tempFlipperId = Math.random().toFixed(5)\n  containerEl.dataset.flipperId = tempFlipperId\n\n  return (selector: string) => {\n    return toArray(\n      containerEl.querySelectorAll(\n        `[data-flipper-id=\"${tempFlipperId}\"] ${selector}`\n      )\n    )\n  }\n}\nconst createScopedSelector = ({\n  containerEl,\n  portalKey\n}: {\n  containerEl?: HTMLElement\n  portalKey?: string\n}): ScopedSelector => {\n  if (portalKey) {\n    return createPortalScopedSelector(portalKey)\n  } else if (containerEl) {\n    return createFlipperScopedSelector(containerEl)\n  } else {\n    return () => []\n  }\n}\n\nconst createGetElementFunc = (scopedSelector: ScopedSelector): GetElement => {\n  return (id: string) => {\n    return scopedSelector(`[${constants.DATA_FLIP_ID}=\"${id}\"]`)[0]\n  }\n}\n\nconst onFlipKeyUpdate = ({\n  cachedOrderedFlipIds = [],\n  inProgressAnimations = {},\n  flippedElementPositionsBeforeUpdate = {},\n  flipCallbacks = {},\n  containerEl,\n  applyTransformOrigin,\n  spring,\n  debug,\n  portalKey,\n  staggerConfig = {},\n  decisionData = {},\n  handleEnterUpdateDelete,\n  onComplete,\n  onStart\n}: OnFlipKeyUpdateArgs) => {\n\n  const flippedElementPositionsAfterUpdate = getFlippedElementPositionsAfterUpdate(\n    {\n      element: containerEl,\n      portalKey\n    }\n  )\n\n  const scopedSelector = createScopedSelector({\n    containerEl,\n    portalKey\n  })\n  const getElement = createGetElementFunc(scopedSelector)\n\n  const isFlipped = (id: string) =>\n    flippedElementPositionsBeforeUpdate[id] &&\n    flippedElementPositionsAfterUpdate[id]\n\n  const unflippedIds = Object.keys(flippedElementPositionsBeforeUpdate)\n    .concat(Object.keys(flippedElementPositionsAfterUpdate))\n    .filter(id => !isFlipped(id))\n\n  const baseArgs: BaseFlipArgs = {\n    flipCallbacks,\n    getElement,\n    flippedElementPositionsBeforeUpdate,\n    flippedElementPositionsAfterUpdate,\n    inProgressAnimations,\n    decisionData\n  }\n\n  const animateUnFlippedElementsArgs = assign({}, baseArgs, {\n    unflippedIds\n  }) as AnimateUnflippedElementsArgs\n\n  const {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  } = animateUnflippedElements(animateUnFlippedElementsArgs)\n\n  const flippedIds: FlippedIds = cachedOrderedFlipIds.filter(isFlipped)\n  // @ts-ignore\n  const animateFlippedElementsArgs: AnimateFlippedElementsArgs = assign(\n    {},\n    baseArgs,\n    {\n      containerEl,\n      flippedIds,\n      applyTransformOrigin,\n      spring,\n      debug,\n      staggerConfig,\n      scopedSelector,\n      onComplete\n    }\n  )\n  if (onStart) onStart(containerEl, decisionData)\n\n  // the function handles putting flipped elements back in their original positions\n  // and returns another function to actually call the flip animation\n  const flip = animateFlippedElements(animateFlippedElementsArgs)\n\n  if (handleEnterUpdateDelete) {\n    handleEnterUpdateDelete({\n      hideEnteringElements,\n      animateEnteringElements,\n      animateExitingElements,\n      animateFlippedElements: flip\n    })\n  } else {\n    hideEnteringElements()\n    animateExitingElements().then(animateEnteringElements)\n    flip()\n  }\n}\n\nexport default onFlipKeyUpdate\n","import {\n  addTupleToObject,\n  getRects,\n  getAllElements\n} from '../utilities'\nimport { FlippedElementPositionsAfterUpdate } from './types'\n\nconst getFlippedElementPositionsAfterUpdate = ({\n  element,\n  portalKey\n}: {\n  element: HTMLElement\n  portalKey?: string\n}): FlippedElementPositionsAfterUpdate => {\n  return (\n    getRects(getAllElements(element, portalKey))\n      .map(([child, childBCR]) => {\n        const computedStyle = window.getComputedStyle(child)\n        return [\n          child.dataset.flipId,\n          {\n            element: child,\n            rect: childBCR,\n            opacity: parseFloat(computedStyle.opacity!),\n            transform: computedStyle.transform\n          }\n        ]\n      })\n      // @ts-ignore\n      .reduce(addTupleToObject, {})\n  )\n}\n\nexport default getFlippedElementPositionsAfterUpdate\n","import { AnimateUnflippedElementsArgs, FragmentTuple } from './types'\n\nconst animateUnflippedElements = ({\n  unflippedIds,\n  flipCallbacks,\n  getElement,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  inProgressAnimations,\n  decisionData\n}: AnimateUnflippedElementsArgs) => {\n  const enteringElementIds = unflippedIds.filter(\n    id => flippedElementPositionsAfterUpdate[id]\n  )\n  const animatedEnteringElementIds = enteringElementIds.filter(\n    id => flipCallbacks[id] && flipCallbacks[id].onAppear\n  )\n\n  const animatedExitingElementIds = unflippedIds.filter(\n    id =>\n      flippedElementPositionsBeforeUpdate[id] &&\n      flipCallbacks[id] &&\n      flipCallbacks[id].onExit\n  )\n\n  const hideEnteringElements = () => {\n    animatedEnteringElementIds.forEach(id => {\n      const element = getElement(id)\n      if (element) {\n        element.style.opacity = '0'\n      }\n    })\n  }\n\n  const animateEnteringElements = () => {\n    animatedEnteringElementIds.forEach((id, i) => {\n      const element = getElement(id)\n      if (element) {\n        flipCallbacks[id].onAppear!(element, i, decisionData)\n      }\n    })\n  }\n\n  let closureResolve: () => void\n\n  const promiseToReturn: Promise<void> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n\n  const fragmentTuples: FragmentTuple[] = []\n  let exitingElementCount = 0\n\n  const onExitCallbacks = animatedExitingElementIds.map((id, i) => {\n    const {\n      domDataForExitAnimations: {\n        element,\n        parent,\n        childPosition: { top, left, width, height }\n      }\n    } = flippedElementPositionsBeforeUpdate[id]\n    // insert back into dom\n    if (getComputedStyle(parent).position === 'static') {\n      parent.style.position = 'relative'\n    }\n    element.style.transform = 'matrix(1, 0, 0, 1, 0, 0)'\n    element.style.position = 'absolute'\n    element.style.top = top + 'px'\n    element.style.left = left + 'px'\n    // taken out of the dom flow, the element might have lost these dimensions\n    element.style.height = height + 'px'\n    element.style.width = width + 'px'\n    let fragmentTuple: FragmentTuple | undefined = fragmentTuples.filter(\n      t => t[0] === parent\n    )[0]\n    if (!fragmentTuple) {\n      fragmentTuple = [parent, document.createDocumentFragment()]\n      fragmentTuples.push(fragmentTuple)\n    }\n    fragmentTuple[1].appendChild(element)\n\n    exitingElementCount += 1\n\n    const stop = () => {\n      try {\n        parent.removeChild(element)\n      } catch (DOMException) {\n        // the element is already gone\n      } finally {\n        exitingElementCount -= 1\n        if (exitingElementCount === 0) {\n          closureResolve()\n        }\n      }\n    }\n    // @ts-ignore\n    inProgressAnimations[id] = { stop }\n    return () => flipCallbacks[id].onExit!(element, i, stop, decisionData)\n  })\n\n  // now append all the fragments from the onExit callbacks\n  // (we use fragments for performance)\n  fragmentTuples.forEach(t => {\n    t[0].appendChild(t[1])\n  })\n\n  if (!onExitCallbacks.length) {\n    closureResolve!()\n  }\n\n  const animateExitingElements = () => {\n    onExitCallbacks.forEach(c => c())\n    return promiseToReturn\n  }\n\n  return {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  }\n}\n\nexport default animateUnflippedElements\n","import React, {\n  FunctionComponent,\n  Children,\n  cloneElement,\n  ReactElement\n} from 'react'\nimport PropTypes from 'prop-types'\nimport { utilities, constants } from '../FlipToolkit'\nimport { FlippedProps, SerializableFlippedProps } from '../FlipToolkit/types'\nimport { FlipContext, PortalContext } from '../Flipper/context'\n\nfunction isFunction(child: any): child is Function {\n  return typeof child === 'function'\n}\n\n// This wrapper creates child components for the main Flipper component\nexport const Flipped: FunctionComponent<SerializableFlippedProps> = ({\n  children,\n  flipId,\n  inverseFlipId,\n  portalKey,\n  ...rest\n}) => {\n  let child = children\n  const isFunctionAsChildren = isFunction(child)\n\n  if (!isFunctionAsChildren) {\n    try {\n      child = Children.only(children)\n    } catch (e) {\n      throw new Error('Each Flipped component must wrap a single child')\n    }\n  }\n\n  // if nothing is being animated, assume everything is being animated\n  if (!rest.scale && !rest.translate && !rest.opacity) {\n    utilities.assign(rest, {\n      translate: true,\n      scale: true,\n      opacity: true\n    })\n  }\n\n  const dataAttributes: Record<string, string | undefined> = {\n    [constants.DATA_FLIP_CONFIG]: JSON.stringify(rest)\n  }\n\n  if (flipId) dataAttributes[constants.DATA_FLIP_ID] = String(flipId)\n  else if (inverseFlipId)\n    dataAttributes[constants.DATA_INVERSE_FLIP_ID] = String(inverseFlipId)\n\n  if (portalKey) {\n    dataAttributes[constants.DATA_PORTAL_KEY] = portalKey\n  }\n  if (isFunctionAsChildren) {\n    return (child as Function)(dataAttributes)\n  }\n  return cloneElement(child as ReactElement<any>, dataAttributes)\n}\n// @ts-ignore\nexport const FlippedWithContext: FunctionComponent<FlippedProps> = ({\n  children,\n  flipId,\n  shouldFlip,\n  shouldInvert,\n  onAppear,\n  onStart,\n  onStartImmediate,\n  onComplete,\n  onExit,\n  onSpringUpdate,\n  ...rest\n}) => {\n  if (!children) {\n    return null\n  }\n  if (rest.inverseFlipId) {\n    return <Flipped {...rest}>{children}</Flipped>\n  }\n\n  return (\n    <PortalContext.Consumer>\n      {portalKey => (\n        <FlipContext.Consumer>\n          {data => {\n            // if there is no surrounding Flipper component,\n            // we don't want to throw an error, so check\n            // that data exists and is not the default string\n            if (utilities.isObject(data) && flipId) {\n              data[flipId] = {\n                shouldFlip,\n                shouldInvert,\n                onAppear,\n                onStart,\n                onStartImmediate,\n                onComplete,\n                onExit,\n                onSpringUpdate\n              }\n            }\n            return (\n              <Flipped flipId={flipId} {...rest} portalKey={portalKey}>\n                {children}\n              </Flipped>\n            )\n          }}\n        </FlipContext.Consumer>\n      )}\n    </PortalContext.Consumer>\n  )\n}\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-ignore\n  FlippedWithContext.propTypes = {\n    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n    inverseFlipId: PropTypes.string,\n    flipId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    opacity: PropTypes.bool,\n    translate: PropTypes.bool,\n    scale: PropTypes.bool,\n    transformOrigin: PropTypes.string,\n    spring: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    onStart: PropTypes.func,\n    onStartImmediate: PropTypes.func,\n    onComplete: PropTypes.func,\n    onAppear: PropTypes.func,\n    onSpringUpdate: PropTypes.func,\n    shouldFlip: PropTypes.func,\n    shouldInvert: PropTypes.func,\n    onExit: PropTypes.func,\n    portalKey: PropTypes.string,\n    stagger: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])\n  }\n}\n\nFlippedWithContext.displayName = 'Flipped'\n\nexport default FlippedWithContext\n","export const DATA_FLIP_ID = 'data-flip-id'\nexport const DATA_INVERSE_FLIP_ID = 'data-inverse-flip-id'\nexport const DATA_FLIP_COMPONENT_ID = 'data-flip-component-id'\nexport const DATA_FLIP_CONFIG = 'data-flip-config'\nexport const DATA_PORTAL_KEY = 'data-portal-key'\nexport const DATA_EXIT_CONTAINER = 'data-exit-container'\n","import { FunctionComponent, cloneElement, ReactElement } from 'react'\nimport { constants } from '../FlipToolkit'\n\nconst ExitContainer: FunctionComponent = ({ children }) => {\n  return cloneElement(children as ReactElement<any>, {\n    [constants.DATA_EXIT_CONTAINER]: true\n  })\n}\n\nexport default ExitContainer\n"],"names":["const","isNumber","x","isObject","Object","prototype","toString","call","toArray","arrayLike","Array","slice","apply","assign","target","args","forEach","arg","nextKey","hasOwnProperty","_onFrame","tweenProp","start","end","position","springPresets","noWobble","stiffness","damping","gentle","veryGentle","wobbly","stiff","normalizeSpring","spring","keys","indexOf","window","requestAnimationFrame","callback","setTimeout","Date","now","performanceNow","performance","removeFirst","array","item","idx","splice","AnimationLooper","run","springSystem","loop","PhysicsState","constructor","velocity","ID","Spring","_id","_springSystem","listeners","_startValue","_currentState","_displacementFromRestThreshold","_endValue","_overshootClampingEnabled","_previousState","_restSpeedThreshold","_tempState","_timeAccumulator","_wasAtRest","_cachedSpringConfig","getId","this","destroy","deregisterSpring","setSpringConfig","springConfig","_springConfig","getCurrentValue","getDisplacementDistanceForState","state","Math","abs","setEndValue","endValue","prevEndValue","isAtRest","activateSpring","let","i","len","length","onChange","onSpringEndStateChange","setVelocity","setCurrentValue","currentValue","listener","onSpringUpdate","setAtRest","setOvershootClampingEnabled","enabled","isOvershooting","tension","advance","time","realDeltaTime","adjustedDeltaTime","aVelocity","aAcceleration","bVelocity","bAcceleration","cVelocity","cAcceleration","friction","tempPosition","tempVelocity","_interpolate","notifyActivate","notifyAtRest","notifyPositionUpdated","filter","Boolean","onSpringActivate","_onActivateCalled","onSpringAtRest","systemShouldAdvance","wasAtRest","alpha","addListener","newListener","push","addOneTimeListener","key","func","removeListener","listenerToRemove","SpringSystem","looper","_activeSprings","_idleSpringIndices","_isIdle","_lastTimeMillis","_springRegistry","createSpring","createSpringWithConfig","registerSpring","getIsIdle","deltaTime","pop","currentTimeMillis","ellapsedMillis","onBeforeIntegrate","onAfterIntegrate","springId","createSuspendedSpring","flipData","overshootClamping","onAnimationEnd","getOnUpdateFunc","flipped","createStaggeredSprings","flippedArray","staggerConfig","reverse","speedConfig","normalizedSpeed","speed","min","max","nextThreshold","setEndValueFuncs","map","cachedGetOnUpdate","onUpdate","bind","convertMatrix3dArrayTo2dArray","matrix","index","rectInViewport","ref","innerHeight","innerWidth","addTupleToObject","acc","curr","getAllElements","element","portalKey","document","querySelectorAll","getRects","flippedElements","child","getBoundingClientRect","createSimpleSpring","onComplete","springVal","values","currentValues","value","reduce","delay","FlipContext","createContext","PortalContext","Flipper","undefined","getSnapshotBeforeUpdate","prevProps","flipKey","props","el","inverseFlippedElements","childIdsToParentBCRs","parentBCRs","childIdsToParents","flipCallbacks","dataset","flipId","onExit","parent","parentNode","closest","exitContainer","bcrIndex","findIndex","n","filteredFlippedElements","flippedElementPositions","domDataForExitAnimations","parentBCR","childPosition","top","childBCR","left","width","height","rect","opacity","parseFloat","getComputedStyle","inProgressAnimations","animatingElements","id","style","transform","cancelInProgressAnimations","concat","cachedOrderedFlipIds","getFlippedElementPositionsBeforeUpdate","componentDidUpdate","_prevState","cachedData","flippedElementPositionsAfterUpdate","computedStyle","getFlippedElementPositionsAfterUpdate","containerEl","scopedSelector","selector","createPortalScopedSelector","tempFlipperId","random","toFixed","flipperId","createFlipperScopedSelector","createScopedSelector","getElement","createGetElementFunc","isFlipped","flippedElementPositionsBeforeUpdate","unflippedIds","baseArgs","decisionData","closureResolve","animatedEnteringElementIds","onAppear","animatedExitingElementIds","promiseToReturn","Promise","resolve","fragmentTuples","exitingElementCount","onExitCallbacks","fragmentTuple","t","createDocumentFragment","appendChild","stop","removeChild","DOMException","c","animateUnflippedElements","animateFlippedElementsArgs","applyTransformOrigin","debug","onStart","flip","flipCompletedPromise","then","flippedIds","obj","completedAnimationIds","firstElement","body","ownerDocument","querySelector","val","flipDataArray","prevRect","currentRect","prevOpacity","currentOpacity","needsForcedMinVals","flipConfig","JSON","parse","flippedSpring","getSpringConfig","flipperSpring","stagger","toReturn","shouldFlip","previous","current","translateDifference","scaleDifference","opacityDifference","currentTransform","Rematrix","toVals","fromVals","transformsArray","translate","scale","invertedChildren","shouldInvert","invertedChildElements","getInvertedChildren","applyStyles","forceMinVals","minHeight","minWidth","stringTransform","join","convertMatrix2dArrayToString","contains","scaleX","scaleY","translateY","inverseVals","translateX","transformString","childFlipConfig","invertTransformsForChildren","createApplyStylesFunc","cachedOnComplete","animateOpacity","onStartCalled","vals","fromVal","onStartImmediate","transformOrigin","isCancellation","delayUntil","initializeFlip","delayedFlip","f","delayUntilSprings","delayUntilStaggers","delayedStaggerKeys","staggerDict","immediateFlip","staggerKey","animateFlippedElements","handleEnterUpdateDelete","hideEnteringElements","animateEnteringElements","animateExitingElements","onFlipKeyUpdate","render","flipperMarkup","React","Provider","className","children","Component","Flipped","isFunctionAsChildren","isFunction","Children","only","e","Error","rest","utilities","dataAttributes","stringify","String","inverseFlipId","cloneElement","FlippedWithContext","Consumer","data","displayName","ExitContainer"],"mappings":"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"}